(self.webpackChunkwebpack_starter=self.webpackChunkwebpack_starter||[]).push([[321],{163:(n,e,o)=>{var t=o(180)((function(n){return n[1]}));t.push([n.id,"body{background:#353940;color:#d5dce8;font-family:sans-serif;margin:0}\n",""]),n.exports=t},235:(n,e,o)=>{"use strict";o.r(e),o.d(e,{default:()=>a});var t=o(565),i=o.n(t),r=o(163),s=o.n(r),c={insert:"head",singleton:!1};i()(s(),c);const a=s().locals||{}},279:(n,e,o)=>{"use strict";const t=4096,i=1e3/60;n.exports={DATA_TEXTURE_WIDTH:t,FRAME_TIME:i,generateConstantsAndUtils:function(n,e){return`#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\nprecision highp usampler2D;\n\nconst int DATA_TEXTURE_WIDTH = 4096;\nconst int DATA_TEXTURE_WIDTH_POWER = ${Math.log2(t)};\nconst uint DATA_TEXTURE_WIDTH_U = 4096u;\nconst uint DATA_TEXTURE_WIDTH_POWER_U = ${Math.log2(t)}u;\nconst vec2 HALF_WORLD_SIZE = vec2(${e.width/2}.0, ${e.height/2}.0);\nconst float FRAME_TIME = ${i};\nconst float GRAVITY = 0.0;\nconst float COLLIDE_FRICTION = 0.0;\nconst float ORTHO_BREAKING_DISTANCE = 1.1;\nconst float DIAG_BRAKING_DISTANCE = ${1.1*Math.SQRT2};\nconst float SPRING_CONSTANT = 0.0004;\nconst float DAMPING_CONSTANT = 0.005;\n\n${o(566)}\n${n}`}}},138:(n,e,o)=>{"use strict";const{FRAME_TIME:t}=o(279),{mod:i,m:r}=o(451),s=i("root",((n,e,i)=>(n(o(235)),{view:()=>i._(i.canvas$simulation({height:512,width:512})),oncreate(n){const e=n.instance.children[0].dom,i=o(227)(e),r=performance.now();let s=0;requestAnimationFrame((function n(){const e=performance.now()-r,o=Math.floor((e-s)/t);if(o>8)throw new Error("Unable to keep up!");for(let n=0;n<o;n++)console.log("Updating"),i();s=Math.floor(e/t)*t,requestAnimationFrame(n)}))}})));r.mount(document.body,s.component)},440:n=>{"use strict";const e=";base64,";n.exports=function(n){console.log("Loading map");const o=function(n){const o=n.indexOf(e)+e.length,t=n.substring(o),i=window.atob(t),r=i.length,s=new Uint8Array(new ArrayBuffer(r));for(let n=0;n<r;n++)s[n]=i.charCodeAt(n);return s.buffer}(n),[t,i]=Array.from(new Uint32Array(o,0,2));console.log(`Width of map: ${t}`),console.log(`Height of map: ${i}`);const r=new Uint8Array(o,8);function s(n,e){return!(n<=0||e<=0||n>=t||e>=i)&&1===r[n+(i-e)*t]}let c=0;for(let n=0;n<t;n++)for(let e=0;e<i;e++)s(n,e)&&c++;c++;const a={isActive:new Uint8Array(c),posVel:new Float32Array(4*c),orthoConnections:new Uint32Array(4*c),diagConnections:new Uint32Array(4*c)},l=new Map;{let n=1;for(let e=0;e<t;e++)for(let o=0;o<i;o++)s(e,o)&&(l.set(JSON.stringify([e,o]),n),n++)}{let n=1;for(let e=0;e<t;e++)for(let o=0;o<i;o++)if(s(e,o)){const r=4*n;a.isActive[n]=1,a.posVel.set([e-t/2,o-i/2,0,0],r);{const n=[];s(e-1,o)&&n.push(l.get(JSON.stringify([e-1,o]))),s(e+1,o)&&n.push(l.get(JSON.stringify([e+1,o]))),s(e,o-1)&&n.push(l.get(JSON.stringify([e,o-1]))),s(e,o+1)&&n.push(l.get(JSON.stringify([e,o+1]))),a.orthoConnections.set(n,r)}{const n=[];s(e-1,o-1)&&n.push(l.get(JSON.stringify([e-1,o-1]))),s(e+1,o-1)&&n.push(l.get(JSON.stringify([e+1,o-1]))),s(e-1,o+1)&&n.push(l.get(JSON.stringify([e-1,o+1]))),s(e+1,o+1)&&n.push(l.get(JSON.stringify([e+1,o+1]))),a.diagConnections.set(n,r)}n++}}return console.log("Finished loading map:"),console.log(a),{sources:a,width:t,height:i}}},474:n=>{"use strict";n.exports="uniform usampler2D isActive;\nuniform sampler2D posVel;\nuniform usampler2D orthoConnections;\nuniform usampler2D diagConnections;\n\nlayout(location = 0) out uint o_isActive;\nlayout(location = 1) out vec4 o_posVel;\nlayout(location = 2) out uvec4 o_orthoConnections;\nlayout(location = 3) out uvec4 o_diagConnections;\n\n\nuint connectionForce(inout vec2 force, float connectionLength, vec4 thisPosVel, uint connection) {\n    ivec2 connectionPos = idFromUint(connection);\n    if (texelFetch(isActive, connectionPos, 0).x == 0u) {\n        return 1u;\n    }\n    vec4 otherPosVel = texelFetch(posVel, connectionPos, 0);\n    vec4 delta = otherPosVel - thisPosVel;\n    float length = length(delta.xy);\n    vec2 direction = delta.xy / length;\n    float forceMag = (length - connectionLength) * SPRING_CONSTANT + dot(delta.zw, direction) * DAMPING_CONSTANT;\n    force += forceMag * direction;\n    return 1u;\n}\n\nvoid main() {\n    ivec2 idPos = ivec2(gl_FragCoord.xy - vec2(0.5));\n\n    uint isActive = texelFetch(isActive, idPos, 0).x;\n    vec4 posVel = texelFetch(posVel, idPos, 0);\n    uvec4 orthoConnections = texelFetch(orthoConnections, idPos, 0);\n    uvec4 diagConnections = texelFetch(diagConnections, idPos, 0);\n\n    vec2 force = vec2(0, -GRAVITY);\n    isActive &= connectionForce(force, 1.0, posVel, orthoConnections.x);\n    isActive &= connectionForce(force, 1.0, posVel, orthoConnections.y);\n    isActive &= connectionForce(force, 1.0, posVel, orthoConnections.z);\n    isActive &= connectionForce(force, 1.0, posVel, orthoConnections.w);\n    isActive &= connectionForce(force, 1.41421356, posVel, orthoConnections.x);\n    isActive &= connectionForce(force, 1.41421356, posVel, orthoConnections.y);\n    isActive &= connectionForce(force, 1.41421356, posVel, orthoConnections.z);\n    isActive &= connectionForce(force, 1.41421356, posVel, orthoConnections.w);\n\n    posVel.zw += force * FRAME_TIME;\n    posVel.xy += posVel.zw * FRAME_TIME;\n    if (abs(posVel.x) > HALF_WORLD_SIZE.x) {\n        posVel.z = -posVel.z * COLLIDE_FRICTION;\n    }\n    if (abs(posVel.y) > HALF_WORLD_SIZE.y) {\n        posVel.w = -posVel.w * COLLIDE_FRICTION;\n    }\n\n    o_isActive = isActive;\n    o_posVel = posVel;\n    o_orthoConnections = orthoConnections;\n    o_diagConnections = diagConnections;\n}\n"},797:n=>{"use strict";n.exports="uniform usampler2D isActive;\nuniform sampler2D posVel;\nuniform usampler2D orthoConnections;\nuniform usampler2D diagConnections;\n\nin vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n"},141:n=>{"use strict";n.exports="flat in uint toKeep;\n\nout vec4 o_color;\n\nvoid main() {\n    if (toKeep == 0u) {\n        discard;\n    }\n    o_color = vec4(1.0, 1.0, 1.0, 1.0);\n}\n"},11:n=>{"use strict";n.exports="uniform usampler2D isActive;\nuniform sampler2D posVel;\nuniform usampler2D orthoConnections;\nuniform usampler2D diagConnections;\n\nin float unused;\nflat out uint toKeep;\n\nvoid main() {\n    ivec2 idPos = idFromInt(gl_VertexID);\n    vec2 pos = texelFetch(posVel, idPos, 0).xy;\n    toKeep = texelFetch(isActive, idPos, 0).x;\n    gl_Position = vec4(pos / HALF_WORLD_SIZE, 0.0, 1.0);\n    gl_PointSize = 1.0;\n}\n"},451:(n,e,o)=>{"use strict";const t=o(22),i=o(216),r=o(367),s=i({h:t,textConvert:n=>`${n}`,combineId:!0,combineClasses:!0}),c=r(s,{partialApply:!0,useDefault:!0});n.exports={mod:c,m:t,HTML:s}},227:(n,e,o)=>{"use strict";const t=o(872),{generateConstantsAndUtils:i}=o(279),{particleTexturesAndFrameBuffer:r}=o(431),s=o(440);n.exports=n=>{console.log("Initializing");const e=t.getContext(n,{powerPreference:"high-performance",failIfMajorPerformanceCaveat:!0,antialias:!1});if(null===e)throw new Error("Unable to get high-performance webgl2 context");const{sources:c,width:a,height:l}=s(o(777));n.width=a,n.height=l,n.style.width=a+"px",n.style.height=l+"px";const u=t.createProgramInfo(e,[i(o(797),n),i(o(474),n)]),f=t.createProgramInfo(e,[i(o(11),n),i(o(141),n)]);let h=r(e,c),p=r(e,c);const A=h.size,d=t.createBufferInfoFromArrays(e,{position:{numComponents:2,data:[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]}}),m=t.createBufferInfoFromArrays(e,{unused:{numComponents:1,data:new Array(A[0]*A[1]).fill(0)}});return console.log("Finished initializing"),function(){t.bindFramebufferInfo(e,p.framebuffer),e.useProgram(u.program),e.drawBuffers([e.COLOR_ATTACHMENT0,e.COLOR_ATTACHMENT1,e.COLOR_ATTACHMENT2,e.COLOR_ATTACHMENT3]),t.setUniformsAndBindTextures(u,h.textures),t.setBuffersAndAttributes(e,u,d),t.drawBufferInfo(e,d);{const n=p;p=h,h=n}t.bindFramebufferInfo(e),e.useProgram(f.program),t.setUniformsAndBindTextures(f,h.textures),t.setBuffersAndAttributes(e,f,m),t.drawBufferInfo(e,m,e.POINTS)}}},431:(n,e,o)=>{"use strict";const t=o(872),{DATA_TEXTURE_WIDTH:i}=o(279);n.exports={particleTexturesAndFrameBuffer:function(n,e){const o={isActive:1,posVel:4,orthoConnections:4,diagConnections:4},r=Object.entries({isActive:{internalFormat:n.R8UI,format:n.RED_INTEGER},posVel:{internalFormat:n.RGBA32F,format:n.RGBA},orthoConnections:{internalFormat:n.RGBA32UI,format:n.RGBA_INTEGER},diagConnections:{internalFormat:n.RGBA32UI,format:n.RGBA_INTEGER}}).reduce(((t,[r,s])=>{const c=e[r],a=o[r],l=Math.ceil(c.length/(i*a)),u=new ArrayBuffer(i*l*a*c.BYTES_PER_ELEMENT),f=new c.constructor(u);return f.set(c),t[r]={min:n.NEAREST,max:n.NEAREST,width:i,height:l,src:f,...s},t}),{}),s=r.isActive.height;Object.values(r).forEach((n=>{if(n.height!==s)throw new Error("Heights are not consistent")}));const c=t.createTextures(n,r);return{textures:c,framebuffer:t.createFramebufferInfo(n,[{attachment:c.isActive},{attachment:c.posVel},{attachment:c.orthoConnections},{attachment:c.diagConnections}],i,s),size:[i,s]}}}},566:n=>{"use strict";n.exports="ivec2 idFromInt(int id) {\n    return ivec2(id & (DATA_TEXTURE_WIDTH - 1), id >> DATA_TEXTURE_WIDTH_POWER);\n}\nivec2 idFromUint(uint id) {\n    return ivec2(id & (DATA_TEXTURE_WIDTH_U - 1u), id >> DATA_TEXTURE_WIDTH_POWER_U);\n}\n"}},n=>{"use strict";n.O(0,[332,754,175,872,347],(()=>{return e=138,n(n.s=e);var e}));n.O()}]);